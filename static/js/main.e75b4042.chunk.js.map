{"version":3,"sources":["algorithms/Pathfinder.js","map/Graph.js","map/GraphNode.js","map/GraphEdge.js","components/Circle.js","components/Edge.js","components/Interface.js","components/Map.js","App.js","serviceWorker.js","index.js"],"names":["PathNode","sourceNode","parent","this","referencedNode","x","xPos","y","yPos","module","exports","graph","algorithm","config","PriorityQueue","priorityQueue","enqueue","priority","findIndex","element","bind","dequeue","shift","startNode","setStartNode","origin","findNode","undefined","Error","endNode","setEndNode","solve","bfs","dfs","djikstra","aStar","newCurrentNode","closedList","start","end","currentNode","push","findAdjacent","foreach","node","unshift","openList","pop","length","edges","map","edge","targetNode","forEach","createPriorityQueue","createpriorityQueue","GraphNode","require","Edge","calculateCost","xDist","yDist","Math","sqrt","addEdge","cost","createNode","nodes","connectNearbyNodes","costThreshold","consideredNode","find","populateGraph","isGrid","generateSeedMap","xInterval","floor","window","innerWidth","yInterval","innerHeight","offset","intervalLength","random","i","j","iDistributed","jDistributed","Circle","data","r","color","setEndpoint","id","className","cx","cy","fill","onClick","e","console","log","props","x1","y1","x2","y2","stroke","Interface","totalNodes","setTotalNodes","setAlgorithm","startSolver","resetSolver","htmlFor","type","name","min","max","onChange","Number","target","value","preventDefault","GraphData","Pathfinder","PathFinder","Map","useState","selectRandomNode","paintStartNode","initialStartNode","randomEndNode","paintEndNode","chooseNodeColor","some","pathNode","printNodeId","item","key","width","height","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e75b4042.chunk.js","sourcesContent":["/**\n * This is the prototype for all algorithms.\n * @param {Object} graph - The graph upon which the Pathfinder is to solve\n *\n * @todo - Stack generator function\n * @todo - Queue generator function\n * @todo - Priority queue generator function\n */\nfunction Pathfinder(graph, algorithm = 'bfs') {\n  this.config = {\n    algorithm: algorithm\n  };\n\n  this.PriorityQueue = () => {\n    let priorityQueue = {};\n    // add with key based on.... hScore?\n    // priorityQueue.createPriorityItem\n    // Object.defineProperty(priorityQueue, )\n\n\n    /**\n     * creates an item to add to a priority queue\n     * @typedef\n     * @constructor\n     * @param {Number} x - x-position\n     * @param {Number} y - y-position\n     * @param {Number} priority - the priority, with higher value = higher priority\n     * @returns {Object} - item with priority\n     */\n    function createPriorityItem(node, priority) {\n      this.node = node;\n      this.priority = priority;\n    }\n\n    /** adds an item in a sorted way. assumes highest priority if priority\n     *  if the priority is not specified\n     *  @param {number} x - the x position of the item\n     *  @param {number} y - the y position of the item\n     *  @param {number} priority - the priority of the item (max priority = 0)\n     */\n    const enqueue = (x, y, priority = 0) => {\n      let priorityIndex = 0;\n\n      if (priority) {\n        priorityIndex = priorityQueue.findIndex(\n          element => element.priority == priority\n        );\n      } else {\n        priority = 0;\n      }\n\n      // place the item in an array sorted by priority\n      // priorityQueue.splice(priorityIndex, prioritisedItem(x, y, priority));\n    };\n\n    priorityQueue.enqueue = enqueue.bind(priorityQueue);\n\n    /**\n     * gives the highest priority item by default.\n     * If the priority is specified, returns an item of that priority\n     * which has been randomly selected.\n     * @returns {Object}\n     */\n    function dequeue() {\n      return this.shift();\n    }\n\n    priorityQueue.dequeue = dequeue.bind(priorityQueue);\n\n    return priorityQueue;\n  };\n  this.startNode = null;\n\n  this.setStartNode = (x, y) => {\n    let origin = graph.findNode(x, y);\n\n    if (origin !== undefined) {\n      // console.debug(graph.findNode(x, y))\n      this.startNode = origin;\n    } else {\n      throw new Error(\n        `Couldn't find the start node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n  this.endNode = () => null;\n\n  this.setEndNode = (x, y) => {\n    let endNode = graph.findNode(x, y);\n    if (endNode) {\n      endNode = endNode;\n    } else {\n      throw new Error(\n        `Couldn't find the end node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n\n  this.solve = algorithm => {\n    switch (algorithm) {\n      case \"bfs\":\n        this.bfs();\n        break;\n      case \"dfs\":\n        this.dfs();\n        break;\n      case \"djistra\":\n        this.djikstra();\n        break;\n      case \"a*\":\n        this.aStar();\n        break;\n      default:\n        this.aStar();\n    }\n  };\n\n  this.bfs = () => {\n\n    const openList = [];\n    const closedList = [];\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let currentNode = start;\n    let newCurrentNode;\n\n    // add the first node (start node) to the closed list with null parent\n    closedList.push(new PathNode(currentNode));\n\n    while (currentNode !== end) {\n      \n      // Make a list of neighour nodes\n      let neighbours = this.findAdjacent(currentNode);\n\n      // add the newly discovered nodes to the back of the openlist\n      neighbours.foreach(node => closedList.unshift(new PathNode(node, currentNode)));\n\n      // decide on the next node to move to\n      newCurrentNode = currentNode.openList.pop().referencedNode;\n\n      // move to the next node\n      closedList.push(new PathNode(newCurrentNode, currentNode));\n      currentNode = newCurrentNode;\n    };\n\n    closedList.push(new PathNode(currentNode));\n\n    // now that it's been solved, traceback from currentNode to origin via parent\n    const solution = [];\n    // set the traceNode to the end of the closedlist\n    let traceNode = closedList[closedList.length - 1];\n    // while (currentNode) {};\n  };\n\n  this.findAdjacent = (node) => {\n    return node.edges.map( edge => edge.targetNode);\n  };\n\n  this.dfs = () => {\n    const openList = [];\n    const closedList = [];\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n\n    while (currentNode !== end) {\n      // add ajacent nodes to open list\n      currentNode.edges.forEach(edge => openList.push(edge.targetNode));\n\n      // decide which one to go to (dfs: whatever is on top of the stack)\n      currentNode = openList.pop();\n      // put it on the closed List\n      closedList.push(new PathNode(currentNode));\n    }\n\n    // once it's solved, backtrack\n    let solvedPath = [];\n    return solvedPath;\n  };\n\n  this.djikstra = () => {\n    let start = this.startNode;\n    let end = this.endNode;\n    let openList = this.createPriorityQueue();\n    let closedList = [];\n  };\n\n  this.aStar = () => {\n    let closedList = this.createPriorityQueue();\n    // find absolute distance to target after travelling down an edge\n    const h = candidateNode => {\n      let manhattanDistance =\n        Math.abs(end.xPos - candidateNode.xPos) +\n        Math.abs(end.yPos - candidateNode.yPos);\n      return manhattanDistance;\n    };\n\n    // current cost so far\n    const g = pathNodeIndex => {\n      let gScore = 0;\n      let finishedBacktrack = false;\n\n      while (!finishedBacktrack) {\n        //TODO traverse backwards through the closedList parent thingy\n        // closedList[pathNodeIndex];\n      }\n\n      return gScore;\n    };\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let openList = this.createpriorityQueue();\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n    while (currentNode !== end) {\n      // map to an array arranged by priority, then join it to the open list\n      //\n    }\n  }\n};\n\n/**\n * a node to go on the closed list stac\n * @param sourceNode {GraphNode} the graph node this represents\n * @param parent {PathNode} - the parent PathNode\n */\nfunction PathNode(sourceNode, parent = null) {\n  this.referencedNode = sourceNode;\n  this.x = sourceNode.xPos;\n  this.y = sourceNode.yPos;\n  this.parent = parent;\n}\n\nmodule.exports = Pathfinder;\n","const GraphNode = require(\"./GraphNode\");\nconst Edge = require(\"./GraphEdge\");\n\n/**\n * Generates a graph map\n * @constructor\n * @classdesc A Graph of interconnected nodes\n */\nfunction Graph() {\n  /**\n   * Calculates the cost along the edge of a node\n   * @method\n   */\n  this.calculateCost = function(sourceNode, targetNode) {\n    let xDist = targetNode.xPos - sourceNode.xPos;\n    let yDist = targetNode.yPos - sourceNode.yPos;\n\n    return Math.sqrt(xDist * xDist + yDist * yDist);\n  };\n\n  /**\n   * Adds an edge between two nodes.\n   * @method\n   */\n  this.addEdge = function(sourceNode, targetNode, cost) {\n    // Figure out the cost if it wasn't passed into this function\n    if (cost == undefined) {\n      cost = this.calculateCost(sourceNode, targetNode);\n    }\n\n    //add the edge to the source node\n    sourceNode.edges.push(new Edge(targetNode, cost));\n  };\n\n  /**\n   * Adds a node to the graph\n   * @method\n   * @param {Number} xPos - The x-position of the node\n   * @param {Number} yPos - The y-position of the node.\n   * @returns {Node} - The node that was just added\n   * @todo Check for pre-existing node before adding another identical one\n   */\n  this.createNode = function(xPos, yPos) {\n    let node = new GraphNode(xPos, yPos);\n    this.nodes.push(node);\n    return node;\n  };\n\n  /**\n   * connects the nearby nodes together\n   * @method\n   * @param {Number} costThreshold - The maximum for which\n   * nodes will be connected\n   */\n  this.connectNearbyNodes = function(costThreshold) {\n    if (this.nodes.length > 0) {\n      for (let node of this.nodes) {\n        // create a list of nodes that are within or equal to the cost threshold\n        this.nodes.forEach(consideredNode => {\n          if (consideredNode !== node) {\n            let cost = this.calculateCost(node, consideredNode);\n            if (cost <= costThreshold) {\n              this.addEdge(node, consideredNode, cost);\n            }\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * finds a node based on the co-ords provided\n   * @param {Number} x - The x-position of the node\n   * @param {Number} y - The y-position of the node\n   * @returns {(Node|undefind)} - Node if exists\n   */\n  this.findNode = function(x, y, radius = 1) {\n    // find closest node based on area search of area defined by radius\n    // return this.nodes.filter(node => {\n    //   let xDist = x - node.xPos;\n    //   let yDist = y - node.yPos;\n    //   return Math.sqrt(xDist * xDist + yDist * yDist) <= radius;\n    // });\n\n    // if the coords are right, return the node\n    return this.nodes.find(node => {\n      return node.x == x && node.y == y;\n    });\n  };\n\n  /**\n   * @member {Array.<GraphNodes>} nodes - A list of nodes\n   */\n  this.nodes = [];\n\n  this.populateGraph = function(isGrid) {\n    if (isGrid) {\n\n    };\n  };\n\n  this.generateSeedMap = () => {\n    const config = {\n      // iMax: Math.floor(0.02 * window.innerWidth),\n      iMax: 16,\n      jMax: 9 \n    };\n\n    let xInterval = Math.floor(window.innerWidth / config.iMax);\n    let yInterval = Math.floor(window.innerHeight / config.jMax);\n\n    const offset = (intervalLength) => Math.random() * intervalLength;\n\n    for (let i = 1; i < config.iMax; i++) {\n      for (let j = 1; j < config.jMax; j++) {\n        let iDistributed = Math.floor((i * xInterval) + offset(xInterval) - offset(xInterval));\n        let jDistributed = Math.floor((j * xInterval) + offset(yInterval) - offset(yInterval));\n        // info.push({x: iDistributed, y: jDistributed});\n        this.createNode(iDistributed, jDistributed);\n      }\n    }\n\n    this.connectNearbyNodes(210);\n  };\n};\n\nmodule.exports = Graph;\n","/**\n * A Node in the graph\n * @constructor\n * @param {Number} xPos - The x-position of the Graph Node\n * @param {Number} yPos - The y-position of the Graph Node\n *\n * @property {Number} xPos - The x-position of the node\n * @property {Number} yPos - The y-position of the node\n * @property {Array.<Edge>} edges - A list of all the edges connected to this node\n */\nmodule.exports = function GraphNode(xPos, yPos) {\n  this.xPos = xPos;\n  this.yPos = yPos;\n  this.edges = [];\n}\n\n","/**\n * An edge connecting two GraphNodes together\n * @constructor\n * @param {Node} sourceNode - the source node\n * @param {Node} targetNode - the target node\n * @prop {Node} sourceNode - the source node\n * @prop {Node} targetNode - the target node\n */\nmodule.exports = function GraphEdge(targetNode, cost) {\n  this.targetNode = targetNode;\n  this.cost = cost;\n};\n","import React from 'react';\n\nexport default function Circle({data, r, color, setEndpoint, id}) {\n\n  const handleClick = (e) => {\n    console.log(e);\n    setEndpoint(data)\n  };\n  return (\n    <circle\n      className=\"circle\"\n      cx={data.xPos}\n      cy={data.yPos}\n      r={r}\n      fill={color}\n      onClick={handleClick}\n      id={id? id : undefined}\n    >\n    </circle>\n  );\n};\n","import React from 'react';\n\nexport default function Edge(props) {\n  return (\n    <line \n      x1={props.x1}\n      y1={props.y1}\n      x2={props.data.targetNode.xPos}\n      y2={props.data.targetNode.yPos}\n      stroke=\"rgba(131, 148, 150, 1)\"\n    />\n  );\n}\n","import React from \"react\";\n\nexport default function Interface({\n  totalNodes,\n  setTotalNodes,\n  setAlgorithm,\n  startSolver,\n  resetSolver\n}) {\n\n\n  const handleNodeChange = e => {\n    setTotalNodes(Number(e.target.value));\n  };\n\n  const handleAlgorithmChange = e => {\n    setAlgorithm(e.target.id);\n  };\n\n  const handleStartCommand = e => {\n    e.preventDefault();\n    startSolver();\n  };\n\n  const handleResetCommand = e => {\n    e.preventDefault();\n    resetSolver();\n  };\n\n  return (\n    <aside>\n      <h1>Pathfinder</h1>\n      <label htmlFor=\"totalNodes\">\n        # of Nodes: {totalNodes}\n          <input\n            type=\"range\"\n            id=\"totalNodes\"\n            name=\"totalNodes\"\n            min=\"2\"\n            max=\"100\"\n            onChange={handleNodeChange}\n          ></input>\n        </label>\n\n      <br />\n\n      <form onChange={handleAlgorithmChange}>\n        <label htmlFor=\"bfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"bfs\"></input>\n          Breadth-First Search\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"dfs\"></input>\n          Depth-First Search\n        </label>\n\n        <label htmlFor=\"djikstra\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"djikstra\"></input>\n          Djikstra's Algorithm\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"aStar\"></input>\n          A* Search\n        </label>\n      </form>\n\n      <div className=\"buttons\">\n        <label htmlFor=\"start\">\n          <button id=\"start\" name=\"start\" onClick={handleStartCommand}>\n          Start\n          </button>\n        </label>\n\n        <label htmlFor=\"reset\">\n          <button id=\"reset\" name=\"reset\" onClick={handleResetCommand}>\n          Reset\n          </button>\n        </label>\n    </div>\n    </aside>\n  );\n}\n","import React, { useState } from \"react\";\nimport Circle from \"./Circle\";\nimport Edge from \"./Edge\";\nimport Interface from \"./Interface\";\nimport PathFinder from \"../algorithms/Pathfinder\";\n\nconst Graph = require(\"../map/Graph\");\nconst GraphData = new Graph();\nconst Pathfinder = new PathFinder(GraphData);\n\n// TODO Implement acess to the closed list so that we can show status of solver\n\nexport default function Map() {\n  const [totalNodes, setTotalNodes] = useState(100);\n  const [closedList, setClosedList] = useState(Pathfinder.closedList);\n  const [algorithm, setAlgorithm] = useState(\"bfs\");\n  const [startNode, setStartNode] = useState();\n  const [endNode, setEndNode] = useState();\n  let solved = false;\n\n  // update the state of the map with the data from the algorithm\n  const tick = () => {\n    // update the Component's closedList in state\n    setClosedList(Pathfinder.closedList);\n    //\n    paint();\n\n    // Call the tick function again\n    if (!solved) {\n      tick();\n    }\n  };\n\n  const paint = () => {};\n\n  const startSolver = () => {\n    console.log(\"solver triggered!\");\n  };\n\n  // clear the map, reset the pathfinding algo\n  const resetSolver = () => {\n    console.log(\"reset solver triggered!\");\n  };\n\n  const setEndpoint = d => {\n    setStartNode(d);\n  };\n\n  const selectRandomNode = () => {\n    return GraphData.nodes[\n      // pick a random node out of the hat\n      Math.floor(Math.random() * Math.floor(GraphData.nodes.length))\n    ];\n  };\n\n  const paintStartNode = () => {\n    // default behaviour: pick a random node\n    if (!startNode) {\n      // make the initial startNode\n      let initialStartNode = selectRandomNode();\n      setStartNode(initialStartNode);\n    }\n  };\n\n  // sets the specified not or a random node as the end node\n  const paintEndNode = node => {\n    // if a node was passed into this function\n    if (node) {\n      setEndNode(node);\n    } else if (\n      // othewise, if theres no end node already defined\n      !endNode ||\n      // or if the end node is actually the start node\n      (endNode.xPos === startNode.xPos && endNode.yPos === startNode.yPos)\n    ) {\n      // set a random node as the start node\n      let randomEndNode = selectRandomNode();\n      setEndNode(randomEndNode);\n    }\n    // run it recursively to check if we set the wrong node\n    paintStartNode();\n  };\n\n  paintStartNode();\n  paintEndNode();\n\n  const chooseNodeColor = node => {\n    if (!closedList) {\n      // normal node color\n      return \"rgba(88, 110, 117, 1)\";\n\n      // if the node data is in the closed list, change its color!\n    } else if (\n      closedList.some(\n        pathNode =>\n          pathNode.x === node.data.xPos && pathNode.y === node.data.yPos\n      )\n    ) {\n      // solarizedmagenta\n      return \"rgba(211, 54, 130, 1)\";\n    }\n  };\n\n  const printNodeId = ({ xPos, yPos }) => {\n    let returnValue = undefined;\n\n    \n    if (startNode && endNode && closedList){\n      // if it's the start node\n      if ([xPos, yPos] === [startNode.xPos, startNode.yPos]) {\n        console.log(\"start\");\n        // or if it's the end node\n      } else if ([xPos, yPos] === [endNode.xPos, endNode.yPos]) {\n        console.log(\"end\");\n      } else {\n        // or if it's on the closedList\n        let nodeIsVisited = closedList.some(item => {\n          return item.xPos === xPos && item.yPos === yPos;\n        });\n\n        if (nodeIsVisited) {\n          console.log('node is visited');\n          // return \"visited\";\n        }\n      }\n    }\n\n    // switch ([xPos, yPos]) {\n    //   // it is the start node\n    //   case [startNode.xPos, startNode.yPos]:\n    //     return \"startNode\";\n    //   // it is the end node\n    //   case [endNode.xPos, endNode.yPos]:\n    //     return \"endNode\";\n    // };\n\n    // check if the node is on the closed list\n\n    // case: closedList.find\n    //   return \"visited\";\n    // default:\n    //   return undefined;\n  };\n\n  let nodes = GraphData.nodes.map((node, key) => {\n    return (\n      <Circle\n        data={node}\n        key={key}\n        r=\"6\"\n        color={chooseNodeColor(node)}\n        setEndpoint={x => setEndpoint(x)}\n        id={printNodeId(node)}\n      />\n    );\n  });\n\n  return (\n    <>\n      <Interface\n        totalNodes={totalNodes}\n        setTotalNodes={x => setTotalNodes(x)}\n        setAlgorithm={x => setAlgorithm(x)}\n        startSolver={() => startSolver()}\n        resetSolver={() => resetSolver()}\n      />\n      <svg width={window.innerWidth} height={window.innerHeight}>\n        {edges}\n        {nodes}\n      </svg>\n    </>\n  );\n}\n\nGraphData.generateSeedMap();\n\n// make a list of the nodes for\n\nlet edges = [];\n\n// put edges on the map\nGraphData.nodes.forEach(node => {\n  let x1 = node.xPos;\n  let y1 = node.yPos;\n  edges.push(\n    node.edges.map((edge, key) => {\n      return (\n        <Edge x1={x1} y1={y1} data={edge} key={key} className={undefined} />\n      );\n    })\n  );\n});\n","import React from 'react';\nimport './App.css';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <main>\n      <Map />\n    </main>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}