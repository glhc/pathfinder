{"version":3,"sources":["algorithms/Pathfinder.js","map/Graph.js","map/GraphNode.js","map/GraphEdge.js","components/Circle.js","components/Edge.js","components/Interface.js","components/Map.js","App.js","serviceWorker.js","index.js"],"names":["PathNode","sourceNode","parent","this","referencedNode","x","xPos","y","yPos","degreesOfSeperation","module","exports","graph","algorithm","config","solution","reset","closedList","openList","obtainSolution","finalPFNode","currentNode","currentSolution","push","console","log","PriorityQueue","priorityQueue","enqueue","priority","findIndex","element","bind","dequeue","shift","startNode","setStartNode","origin","findNode","undefined","Error","endNode","setEndNode","solve","bfs","dfs","djikstra","aStar","start","end","length","neighbour","targetNode","searchForPathNode","pathNode","knownPathNode","find","edges","findAdjacent","node","map","edge","forEach","pop","createPriorityQueue","createpriorityQueue","GraphNode","require","Edge","calculateCost","xDist","yDist","Math","sqrt","addEdge","cost","createNode","nodes","connectNearbyNodes","costThreshold","consideredNode","populateGraph","isGrid","generateSeedMap","xInterval","floor","window","innerWidth","yInterval","innerHeight","offset","intervalLength","random","i","j","iDistributed","jDistributed","Circle","data","r","color","setEndpoint","id","className","cx","cy","fill","onClick","e","x1","y1","x2","y2","info","dx","Interface","totalNodes","setTotalNodes","setAlgorithm","startSolver","resetSolver","htmlFor","type","name","min","max","onChange","Number","target","value","preventDefault","GraphData","Pathfinder","PathFinder","Map","useState","setSolutionList","selectRandomNode","paintStartNode","initialStartNode","randomEndNode","paintEndNode","printNodeId","some","item","key","chooseNodeColor","width","height","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b8d1c9d4.chunk.js","sourcesContent":["/**\n * This is the prototype for all algorithms.\n * @param {Object} graph - The graph upon which the Pathfinder is to solve\n *\n * @todo - Stack generator function\n * @todo - Queue generator function\n * @todo - Priority queue generator function\n */\nfunction PathFinder(graph, algorithm = \"bfs\") {\n  this.config = {\n    algorithm: algorithm\n  };\n\n  this.solution = null;\n\n  this.reset = () => {\n    this.solution = [];\n    this.closedList = [];\n    this.openList = [];\n  };\n\n  this.obtainSolution = (finalPFNode) => {\n    let currentNode = finalPFNode;\n    let currentSolution = [];\n\n    while (currentNode !== null) {\n      currentSolution.push(currentNode.referencedNode);\n      currentNode = currentNode.parent;\n    };\n\n    console.log(currentSolution);\n    return currentSolution;\n  };\n\n  this.PriorityQueue = () => {\n    let priorityQueue = {};\n    // add with key based on.... hScore?\n    // priorityQueue.createPriorityItem\n    // Object.defineProperty(priorityQueue, )\n\n    /**\n     * creates an item to add to a priority queue\n     * @typedef\n     * @constructor\n     * @param {Number} x - x-position\n     * @param {Number} y - y-position\n     * @param {Number} priority - the priority, with higher value = higher priority\n     * @returns {Object} - item with priority\n     */\n    function createPriorityItem(node, priority) {\n      this.node = node;\n      this.priority = priority;\n    }\n\n    /** adds an item in a sorted way. assumes highest priority if priority\n     *  if the priority is not specified\n     *  @param {number} x - the x position of the item\n     *  @param {number} y - the y position of the item\n     *  @param {number} priority - the priority of the item (max priority = 0)\n     */\n    const enqueue = (x, y, priority = 0) => {\n      let priorityIndex = 0;\n\n      if (priority) {\n        priorityIndex = priorityQueue.findIndex(\n          element => element.priority === priority\n        );\n      } else {\n        priority = 0;\n      }\n\n      // place the item in an array sorted by priority\n      // priorityQueue.splice(priorityIndex, prioritisedItem(x, y, priority));\n    };\n\n    priorityQueue.enqueue = enqueue.bind(priorityQueue);\n\n    /**\n     * gives the highest priority item by default.\n     * If the priority is specified, returns an item of that priority\n     * which has been randomly selected.\n     * @returns {Object}\n     */\n    function dequeue() {\n      return this.shift();\n    }\n\n    priorityQueue.dequeue = dequeue.bind(priorityQueue);\n\n    return priorityQueue;\n  };\n\n  this.startNode = null;\n\n  this.setStartNode = (x, y) => {\n    let origin = graph.findNode(x, y);\n\n    if (origin !== undefined) {\n      // console.debug(graph.findNode(x, y))\n      this.startNode = origin;\n    } else {\n      throw new Error(\n        `Couldn't find the start node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n  this.endNode = () => null;\n\n  this.setEndNode = (x, y) => {\n    let endNode = graph.findNode(x, y);\n    if (endNode) {\n      endNode = endNode;\n    } else {\n      throw new Error(\n        `Couldn't find the end node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n\n  this.solve = () => {\n    switch (this.config.algorithm) {\n      case \"bfs\":\n        this.bfs();\n        break;\n      case \"dfs\":\n        this.dfs();\n        break;\n      case \"djistra\":\n        this.djikstra();\n        break;\n      case \"a*\":\n        this.aStar();\n        break;\n      default:\n        this.bfs();\n    }\n  };\n\n  this.closedList = [];\n  this.openList = [];\n\n  this.bfs = () => {\n    const openList = this.openList;\n    const closedList = this.closedList;\n\n    const start = this.startNode;\n    const end = this.endNode;\n\n    // add the first node (start node) to the closed list with null parent\n    openList.push(new PathNode(start));\n\n    while (openList.length > 0) {\n      // choose best node on the open list\n      const currentNode = openList.shift();\n      closedList.push(currentNode);\n\n      if (currentNode.referencedNode === end) {\n        this.solution = this.obtainSolution(currentNode);\n        break;\n      };\n\n      for (let edge of currentNode.referencedNode.edges) {\n        let neighbour = new PathNode(edge.targetNode, currentNode);\n        // do we nkow about this neighbour already\n        const searchForPathNode = (pathNode) => neighbour.x === pathNode.x && neighbour.y === pathNode.y;\n        \n        // look for a knownPathNode that is on the open or closed list\n        let knownPathNode = openList.find(searchForPathNode) || closedList.find(searchForPathNode);\n\n        // if we know this node\n        if (knownPathNode) {\n          // check it for a better solution\n          if (knownPathNode.degreesOfSeperation > neighbour.degreesOfSeperation) {\n            knownPathNode.parent = neighbour.parent;\n            knownPathNode.degreesOfSeperation = neighbour.degreesOfSeperation;\n          }\n        } else {\n          openList.push(neighbour);\n        };\n      };\n    }\n  };\n\n  this.findAdjacent = node => {\n    return node.edges.map(edge => edge.targetNode);\n  };\n\n  // not going to work\n  this.dfs = () => {\n    const openList = [];\n    const closedList = [];\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n\n    while (currentNode !== end) {\n      // add ajacent nodes to open list\n      currentNode.edges.forEach(edge => openList.push(edge.targetNode));\n\n      // decide which one to go to (dfs: whatever is on top of the stack)\n      currentNode = openList.pop();\n      // put it on the closed List\n      closedList.push(new PathNode(currentNode));\n    }\n\n    // once it's solved, backtrack\n    let solvedPath = [];\n    return solvedPath;\n  };\n\n\n  // TODO implement setting of this.closedList to empty to empty priority queue\n  this.djikstra = () => {\n    let start = this.startNode;\n    let end = this.endNode;\n    let openList = this.createPriorityQueue();\n    let closedList = [];\n  };\n\n  this.aStar = () => {\n    let closedList = this.createPriorityQueue();\n    // find absolute distance to target after travelling down an edge\n    const h = candidateNode => {\n      let manhattanDistance =\n        Math.abs(end.xPos - candidateNode.xPos) +\n        Math.abs(end.yPos - candidateNode.yPos);\n      return manhattanDistance;\n    };\n\n    // current cost so far\n    const g = pathNodeIndex => {\n      let gScore = 0;\n      let finishedBacktrack = false;\n\n      while (!finishedBacktrack) {\n        //TODO traverse backwards through the closedList parent thingy\n        // closedList[pathNodeIndex];\n      }\n\n      return gScore;\n    };\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let openList = this.createpriorityQueue();\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n    while (currentNode !== end) {\n      // map to an array arranged by priority, then join it to the open list\n      //\n    }\n  };\n}\n\n/**\n * a node to go on the closed list stac\n * @param sourceNode {GraphNode} the graph node this represents\n * @param parent {PathNode} - the parent PathNode\n */\nfunction PathNode(sourceNode, parent = null) {\n  this.referencedNode = sourceNode;\n  this.x = sourceNode.xPos;\n  this.y = sourceNode.yPos;\n  this.parent = parent;\n\n  this.degreesOfSeperation = parent === null ? 0 : parent.degreesOfSeperation + 1;\n}\n\nmodule.exports = PathFinder;\n","const GraphNode = require(\"./GraphNode\");\nconst Edge = require(\"./GraphEdge\");\n\n/**\n * Generates a graph map\n * @constructor\n * @classdesc A Graph of interconnected nodes\n */\nfunction Graph() {\n  /**\n   * Calculates the cost along the edge of a node\n   * @method\n   */\n  this.calculateCost = function(sourceNode, targetNode) {\n    let xDist = targetNode.xPos - sourceNode.xPos;\n    let yDist = targetNode.yPos - sourceNode.yPos;\n\n    return Math.sqrt(xDist * xDist + yDist * yDist);\n  };\n\n  /**\n   * Adds an edge between two nodes.\n   * @method\n   */\n  this.addEdge = function(sourceNode, targetNode, cost) {\n    // Figure out the cost if it wasn't passed into this function\n    if (cost === undefined) {\n      cost = this.calculateCost(sourceNode, targetNode);\n    }\n\n    //add the edge to the source node\n    sourceNode.edges.push(new Edge(targetNode, cost));\n  };\n\n  /**\n   * Adds a node to the graph\n   * @method\n   * @param {Number} xPos - The x-position of the node\n   * @param {Number} yPos - The y-position of the node.\n   * @returns {Node} - The node that was just added\n   * @todo Check for pre-existing node before adding another identical one\n   */\n  this.createNode = function(xPos, yPos) {\n    let node = new GraphNode(xPos, yPos);\n    this.nodes.push(node);\n    return node;\n  };\n\n  /**\n   * connects the nearby nodes together\n   * @method\n   * @param {Number} costThreshold - The maximum for which\n   * nodes will be connected\n   */\n  this.connectNearbyNodes = function(costThreshold) {\n    if (this.nodes.length > 0) {\n      for (let node of this.nodes) {\n        // create a list of nodes that are within or equal to the cost threshold\n        this.nodes.forEach(consideredNode => {\n          if (consideredNode !== node) {\n            let cost = this.calculateCost(node, consideredNode);\n            if (cost <= costThreshold) {\n              this.addEdge(node, consideredNode, cost);\n            }\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * finds a node based on the co-ords provided\n   * @param {Number} x - The x-position of the node\n   * @param {Number} y - The y-position of the node\n   * @returns {(Node|undefind)} - Node if exists\n   */\n  this.findNode = function(x, y, radius = 1) {\n    // find closest node based on area search of area defined by radius\n    // return this.nodes.filter(node => {\n    //   let xDist = x - node.xPos;\n    //   let yDist = y - node.yPos;\n    //   return Math.sqrt(xDist * xDist + yDist * yDist) <= radius;\n    // });\n\n    // if the coords are right, return the node\n    return this.nodes.find(node => {\n      return node.x === x && node.y === y;\n    });\n  };\n\n  /**\n   * @member {Array.<GraphNodes>} nodes - A list of nodes\n   */\n  this.nodes = [];\n\n  this.populateGraph = function(isGrid) {\n    if (isGrid) {\n\n    };\n  };\n\n  this.generateSeedMap = () => {\n    const config = {\n      // iMax: Math.floor(0.02 * window.innerWidth),\n      iMax: 10,\n      jMax: 2 \n    };\n\n    let xInterval = Math.floor(window.innerWidth / config.iMax);\n    let yInterval = Math.floor(window.innerHeight / config.jMax);\n\n    const offset = (intervalLength) => Math.random() * intervalLength;\n\n    for (let i = 1; i < config.iMax; i++) {\n      for (let j = 1; j < config.jMax; j++) {\n        let iDistributed = Math.floor((i * xInterval) + offset(xInterval) - offset(xInterval));\n        let jDistributed = Math.floor((j * xInterval) + offset(yInterval) - offset(yInterval));\n        // info.push({x: iDistributed, y: jDistributed});\n        this.createNode(iDistributed, jDistributed);\n      }\n    }\n\n    this.connectNearbyNodes(210);\n  };\n};\n\nmodule.exports = Graph;\n","/**\n * A Node in the graph\n * @constructor\n * @param {Number} xPos - The x-position of the Graph Node\n * @param {Number} yPos - The y-position of the Graph Node\n *\n * @property {Number} xPos - The x-position of the node\n * @property {Number} yPos - The y-position of the node\n * @property {Array.<Edge>} edges - A list of all the edges connected to this node\n */\nmodule.exports = function GraphNode(xPos, yPos) {\n  this.xPos = xPos;\n  this.yPos = yPos;\n  this.edges = [];\n}\n\n","/**\n * An edge connecting two GraphNodes together\n * @constructor\n * @param {Node} sourceNode - the source node\n * @param {Node} targetNode - the target node\n * @prop {Node} sourceNode - the source node\n * @prop {Node} targetNode - the target node\n */\nmodule.exports = function GraphEdge(targetNode, cost) {\n  this.targetNode = targetNode;\n  this.cost = cost;\n};\n","import React from 'react';\n\nexport default function Circle({data, r, color, setEndpoint, id}) {\n\n  const handleClick = (e) => {\n    console.log(e);\n    setEndpoint(data)\n  };\n  return (\n    <circle\n      className=\"circle\"\n      cx={data.xPos}\n      cy={data.yPos}\n      r={r}\n      fill={color}\n      onClick={handleClick}\n      id={id? id : undefined}\n    >\n    </circle>\n  );\n};\n","import React from \"react\";\n\nexport default function Edge({ x1, y1, data }) {\n  const displayStats = true;\n  const x2 = data.targetNode.xPos;\n  const y2 = data.targetNode.yPos;\n\n\n  const info = (\n    <text\n      x={(x1 + (x1 + x2) / 2) + 'px'}\n      y={(y1 + (y1 + y2) / 2) + 'px'}\n      dx=\"5px\"\n    >\n    </text>\n  );\n\n  return (\n    <>\n      <line x1={x1} y1={y1} x2={x2} y2={y2}>\n      </line>\n      {displayStats && info}\n    </>\n  );\n}\n","import React from \"react\";\n\nexport default function Interface({\n  totalNodes,\n  setTotalNodes,\n  setAlgorithm,\n  startSolver,\n  resetSolver\n}) {\n\n\n  const handleNodeChange = e => {\n    setTotalNodes(Number(e.target.value));\n  };\n\n  const handleAlgorithmChange = e => {\n    setAlgorithm(e.target.id);\n  };\n\n  const handleStartCommand = e => {\n    e.preventDefault();\n    startSolver();\n  };\n\n  const handleResetCommand = e => {\n    e.preventDefault();\n    resetSolver();\n  };\n\n  return (\n    <aside>\n      <h1>Pathfinder</h1>\n      <label htmlFor=\"totalNodes\">\n        # of Nodes: {totalNodes}\n          <input\n            type=\"range\"\n            id=\"totalNodes\"\n            name=\"totalNodes\"\n            min=\"2\"\n            max=\"100\"\n            onChange={handleNodeChange}\n          ></input>\n        </label>\n\n      <br />\n\n      <form onChange={handleAlgorithmChange}>\n        <label htmlFor=\"bfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"bfs\"></input>\n          Breadth-First Search\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"dfs\"></input>\n          Depth-First Search\n        </label>\n\n        <label htmlFor=\"djikstra\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"djikstra\"></input>\n          Djikstra's Algorithm\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"aStar\"></input>\n          A* Search\n        </label>\n      </form>\n\n      <div className=\"buttons\">\n        <label htmlFor=\"start\">\n          <button id=\"start\" name=\"start\" onClick={handleStartCommand}>\n          Start\n          </button>\n        </label>\n\n        <label htmlFor=\"reset\">\n          <button id=\"reset\" name=\"reset\" onClick={handleResetCommand}>\n          Reset\n          </button>\n        </label>\n    </div>\n    </aside>\n  );\n}\n","import React, { useState } from \"react\";\nimport Circle from \"./Circle\";\nimport Edge from \"./Edge\";\nimport Interface from \"./Interface\";\nimport PathFinder from \"../algorithms/Pathfinder\";\n\nconst Graph = require(\"../map/Graph\");\nconst GraphData = new Graph();\nconst Pathfinder = new PathFinder(GraphData);\n\n// TODO Implement acess to the closed list so that we can show status of solver\n\nexport default function Map() {\n  const [totalNodes, setTotalNodes] = useState(100);\n  const [closedList, setClosedList] = useState(Pathfinder.closedList);\n  const [algorithm, setAlgorithm] = useState(\"bfs\");\n  const [startNode, setStartNode] = useState();\n  const [endNode, setEndNode] = useState();\n  const [solutionList, setSolutionList] = useState([]);\n  let solved = false;\n\n  // update the state of the map with the data from the algorithm\n  const tick = () => {\n    // update the Component's closedList in state\n    setClosedList(Pathfinder.closedList);\n    //\n    paint();\n\n    // Call the tick function again\n    if (!solved) {\n      tick();\n    }\n  };\n\n  const paint = () => {};\n\n  const startSolver = () => {\n    Pathfinder.startNode = startNode;\n    Pathfinder.endNode = endNode;\n    Pathfinder.solve();\n    solved = true;\n    setSolutionList(Pathfinder.solution);\n  };\n\n  // clear the map, reset the pathfinding algo\n  const resetSolver = () => {\n    console.log(\"reset solver triggered!\");\n  };\n\n  const setEndpoint = d => {\n    setStartNode(d);\n  };\n\n  const selectRandomNode = () => {\n    return GraphData.nodes[\n      // pick a random node out of the hat\n      Math.floor(Math.random() * Math.floor(GraphData.nodes.length))\n    ];\n  };\n\n  const paintStartNode = () => {\n    // default behaviour: pick a random node\n    if (!startNode) {\n      // make the initial startNode\n      let initialStartNode = selectRandomNode();\n      setStartNode(initialStartNode);\n    }\n  };\n\n  // sets the specified not or a random node as the end node\n  const paintEndNode = node => {\n    // if a node was passed into this function\n    if (node) {\n      setEndNode(node);\n    } else if (\n      // othewise, if theres no end node already defined\n      !endNode ||\n      // or if the end node is actually the start node\n      (endNode.xPos === startNode.xPos && endNode.yPos === startNode.yPos)\n    ) {\n      // set a random node as the start node\n      let randomEndNode = selectRandomNode();\n      setEndNode(randomEndNode);\n    }\n    // run it recursively to check if we set the wrong node\n    paintStartNode();\n  };\n\n  paintStartNode();\n  paintEndNode();\n\n  const chooseNodeColor = node => {\n    // if (!closedList) {\n    //   // normal node color\n    //   return \"rgba(88, 110, 117, 1)\";\n\n    //   // if the node data is in the closed list, change its color!\n    // } else if (\n    //   closedList.some(\n    //     pathNode =>\n    //       pathNode.x === node.data.xPos && pathNode.y === node.data.yPos\n    //   )\n    // ) {\n    //   // solarizedmagenta\n    //   return \"rgba(211, 54, 130, 1)\";\n    // }\n  };\n\n  const printNodeId = ({ xPos, yPos }) => {\n    let returnValue = undefined;\n\n    \n    if (startNode && endNode && closedList){\n      // if it's the start node\n      if (xPos === startNode.xPos && yPos === startNode.yPos) {\n        return \"startNode\";\n        // or if it's the end node\n      } else if (xPos === endNode.xPos && yPos === endNode.yPos) {\n        return \"endNode\";\n      } else {\n        // or if it's on the closedList\n        let nodeIsVisited = closedList.some(item => {\n          return item.xPos === xPos && item.yPos === yPos;\n        });\n\n        if (nodeIsVisited) {\n          return \"visited\";\n        }\n      }\n    }\n  };\n\n  let nodes = GraphData.nodes.map((node, key) => {\n    return (\n      <Circle\n        data={node}\n        key={key}\n        r=\"6\"\n        color={chooseNodeColor(node)}\n        setEndpoint={x => setEndpoint(x)}\n        id={printNodeId(node)}\n      />\n    );\n  });\n\n  return (\n    <>\n      <Interface\n        totalNodes={totalNodes}\n        setTotalNodes={x => setTotalNodes(x)}\n        setAlgorithm={x => setAlgorithm(x)}\n        startSolver={() => startSolver()}\n        resetSolver={() => resetSolver()}\n      />\n      <svg width={window.innerWidth} height={window.innerHeight}>\n        {edges}\n        {nodes}\n      </svg>\n    </>\n  );\n};\n\nGraphData.generateSeedMap();\n\n// make a list of the nodes for\n\nlet edges = [];\n\n// put edges on the map\nGraphData.nodes.forEach(node => {\n  let x1 = node.xPos;\n  let y1 = node.yPos;\n  edges.push(\n    node.edges.map((edge, key) => {\n      return (\n        <Edge x1={x1} y1={y1} data={edge} key={key} className={undefined} />\n      );\n    })\n  );\n});\n","import React from 'react';\nimport './App.css';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <main>\n      <Map />\n    </main>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}