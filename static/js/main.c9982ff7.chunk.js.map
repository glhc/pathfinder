{"version":3,"sources":["map/Graph.js","map/GraphNode.js","map/GraphEdge.js","components/Circle.js","components/Edge.js","components/Interface.js","algorithms/Pathfinder.js","components/Map.js","App.js","serviceWorker.js","index.js"],"names":["GraphNode","require","Edge","module","exports","this","calculateCost","sourceNode","targetNode","xDist","xPos","yDist","yPos","Math","sqrt","addEdge","cost","undefined","edges","push","createNode","node","nodes","connectNearbyNodes","costThreshold","length","forEach","consideredNode","findNode","x","y","find","populateGraph","isGrid","generateSeedMap","config","xInterval","floor","window","innerWidth","yInterval","innerHeight","offset","intervalLength","random","i","j","iDistributed","jDistributed","Circle","data","r","color","setEndpoint","id","className","cx","cy","fill","onClick","e","console","log","x1","y1","x2","y2","info","dx","Interface","totalNodes","setTotalNodes","setAlgorithm","startSolver","resetSolver","htmlFor","type","name","min","max","onChange","Number","target","value","preventDefault","PathNode","parent","referencedNode","degreesOfSeperation","g","PathFinder","graph","algorithm","solution","reset","closedList","openList","obtainSolution","finalPFNode","currentNode","currentSolution","PriorityQueue","priorityQueue","enqueue","priority","findIndex","element","bind","dequeue","shift","startNode","setStartNode","origin","Error","endNode","setEndNode","solve","bfs","dfs","djikstra","aStar","start","end","edge","neighbour","searchForPathNode","pathNode","knownPathNode","findAdjacent","map","sort","a","b","createPriorityQueue","createpriorityQueue","GraphData","Pathfinder","Map","useState","setSolutionList","handleAlgorithmChange","newAlgorithm","selectRandomNode","paintStartNode","initialStartNode","randomEndNode","paintEndNode","printNodeId","some","item","key","chooseNodeColor","width","height","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c9982ff7.chunk.js","sourcesContent":["const GraphNode = require(\"./GraphNode\");\nconst Edge = require(\"./GraphEdge\");\n\n/**\n * Generates a graph map\n * @constructor\n * @classdesc A Graph of interconnected nodes\n */\nfunction Graph() {\n  /**\n   * Calculates the cost along the edge of a node\n   * @method\n   */\n  this.calculateCost = function(sourceNode, targetNode) {\n    let xDist = targetNode.xPos - sourceNode.xPos;\n    let yDist = targetNode.yPos - sourceNode.yPos;\n\n    return Math.sqrt(xDist * xDist + yDist * yDist);\n  };\n\n  /**\n   * Adds an edge between two nodes.\n   * @method\n   */\n  this.addEdge = function(sourceNode, targetNode, cost) {\n    // Figure out the cost if it wasn't passed into this function\n    if (cost === undefined) {\n      cost = this.calculateCost(sourceNode, targetNode);\n    }\n\n    //add the edge to the source node\n    sourceNode.edges.push(new Edge(targetNode, cost));\n  };\n\n  /**\n   * Adds a node to the graph\n   * @method\n   * @param {Number} xPos - The x-position of the node\n   * @param {Number} yPos - The y-position of the node.\n   * @returns {Node} - The node that was just added\n   * @todo Check for pre-existing node before adding another identical one\n   */\n  this.createNode = function(xPos, yPos) {\n    let node = new GraphNode(xPos, yPos);\n    this.nodes.push(node);\n    return node;\n  };\n\n  /**\n   * connects the nearby nodes together\n   * @method\n   * @param {Number} costThreshold - The maximum for which\n   * nodes will be connected\n   */\n  this.connectNearbyNodes = function(costThreshold) {\n    if (this.nodes.length > 0) {\n      for (let node of this.nodes) {\n        // create a list of nodes that are within or equal to the cost threshold\n        this.nodes.forEach(consideredNode => {\n          if (consideredNode !== node) {\n            let cost = this.calculateCost(node, consideredNode);\n            if (cost <= costThreshold) {\n              this.addEdge(node, consideredNode, cost);\n            }\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * finds a node based on the co-ords provided\n   * @param {Number} x - The x-position of the node\n   * @param {Number} y - The y-position of the node\n   * @returns {(Node|undefind)} - Node if exists\n   */\n  this.findNode = function(x, y, radius = 1) {\n    // find closest node based on area search of area defined by radius\n    // return this.nodes.filter(node => {\n    //   let xDist = x - node.xPos;\n    //   let yDist = y - node.yPos;\n    //   return Math.sqrt(xDist * xDist + yDist * yDist) <= radius;\n    // });\n\n    // if the coords are right, return the node\n    return this.nodes.find(node => {\n      return node.x === x && node.y === y;\n    });\n  };\n\n  /**\n   * @member {Array.<GraphNodes>} nodes - A list of nodes\n   */\n  this.nodes = [];\n\n  this.populateGraph = function(isGrid) {\n    if (isGrid) {\n\n    };\n  };\n\n  this.generateSeedMap = () => {\n    const config = {\n      // iMax: Math.floor(0.02 * window.innerWidth),\n      iMax: 10,\n      jMax: 2 \n    };\n\n    let xInterval = Math.floor(window.innerWidth / config.iMax);\n    let yInterval = Math.floor(window.innerHeight / config.jMax);\n\n    const offset = (intervalLength) => Math.random() * intervalLength;\n\n    for (let i = 1; i < config.iMax; i++) {\n      for (let j = 1; j < config.jMax; j++) {\n        let iDistributed = Math.floor((i * xInterval) + offset(xInterval) - offset(xInterval));\n        let jDistributed = Math.floor((j * xInterval) + offset(yInterval) - offset(yInterval));\n        // info.push({x: iDistributed, y: jDistributed});\n        this.createNode(iDistributed, jDistributed);\n      }\n    }\n\n    this.connectNearbyNodes(210);\n  };\n};\n\nmodule.exports = Graph;\n","/**\n * A Node in the graph\n * @constructor\n * @param {Number} xPos - The x-position of the Graph Node\n * @param {Number} yPos - The y-position of the Graph Node\n *\n * @property {Number} xPos - The x-position of the node\n * @property {Number} yPos - The y-position of the node\n * @property {Array.<Edge>} edges - A list of all the edges connected to this node\n */\nmodule.exports = function GraphNode(xPos, yPos) {\n  this.xPos = xPos;\n  this.yPos = yPos;\n  this.edges = [];\n}\n\n","/**\n * An edge connecting two GraphNodes together\n * @constructor\n * @param {Node} sourceNode - the source node\n * @param {Node} targetNode - the target node\n * @prop {Node} sourceNode - the source node\n * @prop {Node} targetNode - the target node\n */\nmodule.exports = function GraphEdge(targetNode, cost) {\n  this.targetNode = targetNode;\n  this.cost = cost;\n};\n","import React from 'react';\n\nexport default function Circle({data, r, color, setEndpoint, id}) {\n\n  const handleClick = (e) => {\n    console.log(e);\n    setEndpoint(data)\n  };\n  return (\n    <circle\n      className=\"circle\"\n      cx={data.xPos}\n      cy={data.yPos}\n      r={r}\n      fill={color}\n      onClick={handleClick}\n      id={id? id : undefined}\n    >\n    </circle>\n  );\n};\n","import React from \"react\";\n\nexport default function Edge({ x1, y1, data }) {\n  const displayStats = true;\n  const x2 = data.targetNode.xPos;\n  const y2 = data.targetNode.yPos;\n\n\n  const info = (\n    <text\n      x={(x1 + (x1 + x2) / 2) + 'px'}\n      y={(y1 + (y1 + y2) / 2) + 'px'}\n      dx=\"5px\"\n    >\n    </text>\n  );\n\n  return (\n    <>\n      <line x1={x1} y1={y1} x2={x2} y2={y2}>\n      </line>\n      {displayStats && info}\n    </>\n  );\n}\n","import React from \"react\";\n\nexport default function Interface({\n  totalNodes,\n  setTotalNodes,\n  setAlgorithm,\n  startSolver,\n  resetSolver\n}) {\n\n\n  const handleNodeChange = e => {\n    setTotalNodes(Number(e.target.value));\n  };\n\n  const handleAlgorithmChange = e => {\n    setAlgorithm(e.target.id);\n  };\n\n  const handleStartCommand = e => {\n    e.preventDefault();\n    startSolver();\n  };\n\n  const handleResetCommand = e => {\n    e.preventDefault();\n    resetSolver();\n  };\n\n  return (\n    <aside>\n      <h1>Pathfinder</h1>\n      <label htmlFor=\"totalNodes\">\n        # of Nodes: {totalNodes}\n          <input\n            type=\"range\"\n            id=\"totalNodes\"\n            name=\"totalNodes\"\n            min=\"2\"\n            max=\"100\"\n            onChange={handleNodeChange}\n          ></input>\n        </label>\n\n      <br />\n\n      <form onChange={handleAlgorithmChange}>\n        <label htmlFor=\"bfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"bfs\"></input>\n          Breadth-First Search\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"dfs\"></input>\n          Depth-First Search\n        </label>\n\n        <label htmlFor=\"djikstra\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"djikstra\"></input>\n          Djikstra's Algorithm\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"aStar\"></input>\n          A* Search\n        </label>\n      </form>\n\n      <div className=\"buttons\">\n        <label htmlFor=\"start\">\n          <button id=\"start\" name=\"start\" onClick={handleStartCommand}>\n          Start\n          </button>\n        </label>\n\n        <label htmlFor=\"reset\">\n          <button id=\"reset\" name=\"reset\" onClick={handleResetCommand}>\n          Reset\n          </button>\n        </label>\n    </div>\n    </aside>\n  );\n}\n","/**\n * This is the prototype for all algorithms.\n * @param {Object} graph - The graph upon which the Pathfinder is to solve\n *\n * @todo - Stack generator function\n * @todo - Queue generator function\n * @todo - Priority queue generator function\n */\nfunction PathFinder(graph, algorithm = \"bfs\") {\n  this.config = {\n    algorithm: algorithm,\n  };\n\n  this.solution = null;\n\n  this.reset = () => {\n    this.solution = [];\n    this.closedList = [];\n    this.openList = [];\n  };\n\n  this.obtainSolution = (finalPFNode) => {\n    let currentNode = finalPFNode;\n    let currentSolution = [];\n\n    while (currentNode !== null) {\n      currentSolution.push(currentNode.referencedNode);\n      currentNode = currentNode.parent;\n    };\n\n    console.log(currentSolution);\n    return currentSolution;\n  };\n\n  this.PriorityQueue = () => {\n    let priorityQueue = {};\n    // add with key based on.... hScore?\n    // priorityQueue.createPriorityItem\n    // Object.defineProperty(priorityQueue, )\n\n    /**\n     * creates an item to add to a priority queue\n     * @typedef\n     * @constructor\n     * @param {Number} x - x-position\n     * @param {Number} y - y-position\n     * @param {Number} priority - the priority, with higher value = higher priority\n     * @returns {Object} - item with priority\n     */\n    function createPriorityItem(node, priority) {\n      this.node = node;\n      this.priority = priority;\n    }\n\n    /** adds an item in a sorted way. assumes highest priority if priority\n     *  if the priority is not specified\n     *  @param {number} x - the x position of the item\n     *  @param {number} y - the y position of the item\n     *  @param {number} priority - the priority of the item (max priority = 0)\n     */\n    const enqueue = (x, y, priority = 0) => {\n      let priorityIndex = 0;\n\n      if (priority) {\n        priorityIndex = priorityQueue.findIndex(\n          element => element.priority === priority\n        );\n      } else {\n        priority = 0;\n      }\n\n      // place the item in an array sorted by priority\n      // priorityQueue.splice(priorityIndex, prioritisedItem(x, y, priority));\n    };\n\n    priorityQueue.enqueue = enqueue.bind(priorityQueue);\n\n    /**\n     * gives the highest priority item by default.\n     * If the priority is specified, returns an item of that priority\n     * which has been randomly selected.\n     * @returns {Object}\n     */\n    function dequeue() {\n      return this.shift();\n    }\n\n    priorityQueue.dequeue = dequeue.bind(priorityQueue);\n\n    return priorityQueue;\n  };\n\n  this.startNode = null;\n\n  this.setStartNode = (x, y) => {\n    let origin = graph.findNode(x, y);\n\n    if (origin !== undefined) {\n      // console.debug(graph.findNode(x, y))\n      this.startNode = origin;\n    } else {\n      throw new Error(\n        `Couldn't find the start node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n  this.endNode = () => null;\n\n  this.setEndNode = (x, y) => {\n    let endNode = graph.findNode(x, y);\n    if (endNode) {\n      endNode = endNode;\n    } else {\n      throw new Error(\n        `Couldn't find the end node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n\n  this.solve = () => {\n    switch (this.config.algorithm) {\n      case \"bfs\":\n        this.bfs();\n        break;\n      case \"dfs\":\n        this.dfs();\n        break;\n      case \"djistra\":\n        this.djikstra();\n        break;\n      case \"a*\":\n        this.aStar();\n        break;\n      default:\n        this.bfs();\n    }\n  };\n\n  this.closedList = [];\n  this.openList = [];\n\n  this.bfs = () => {\n    const openList = this.openList;\n    const closedList = this.closedList;\n\n    const start = this.startNode;\n    const end = this.endNode;\n\n    // add the first node (start node) to the closed list with null parent\n    openList.push(new PathNode(start));\n\n    while (openList.length > 0) {\n      // choose best node on the open list\n      const currentNode = openList.shift();\n      closedList.push(currentNode);\n\n      if (currentNode.referencedNode === end) {\n        this.solution = this.obtainSolution(currentNode);\n        break;\n      };\n\n      for (let edge of currentNode.referencedNode.edges) {\n        let neighbour = new PathNode(edge.targetNode, currentNode, edge.cost);\n        // do we nkow about this neighbour already\n        const searchForPathNode = (pathNode) => neighbour.x === pathNode.x && neighbour.y === pathNode.y;\n        \n        // look for a knownPathNode that is on the open or closed list\n        let knownPathNode = openList.find(searchForPathNode) || closedList.find(searchForPathNode);\n\n        // if we know this node\n        if (knownPathNode) {\n          // check it for a better solution\n          if (knownPathNode.degreesOfSeperation > neighbour.degreesOfSeperation) {\n            knownPathNode.parent = neighbour.parent;\n            knownPathNode.degreesOfSeperation = neighbour.degreesOfSeperation;\n            knownPathNode.g = neighbour.g;\n          }\n        } else {\n          openList.push(neighbour);\n        };\n      };\n    }\n  };\n\n  this.findAdjacent = node => {\n    return node.edges.map(edge => edge.targetNode);\n  };\n\n  // not going to work\n  this.dfs = () => {\n  };\n\n\n  // TODO implement setting of this.closedList to empty to empty priority queue\n  // TODO define cost to pass into pathnodes\n  // TODO when a known node is updated, the gscore, hscore, fscore would update and so would the priority\n  this.djikstra = () => {\n    debugger;\n    console.log('djistra triggered');\n    const openList = this.openList;\n    const closedList = this.closedList;\n\n    const start = this.startNode;\n    const end = this.endNode;\n\n    // add the first node (start node) to the closed list with null parent\n    openList.push(new PathNode(start));\n\n    while (openList.length > 0) {\n      // choose best node on the open list\n      const currentNode = openList.shift();\n      closedList.push(currentNode);\n\n      if (currentNode.referencedNode === end) {\n        this.solution = this.obtainSolution(currentNode);\n        break;\n      };\n\n      for (let edge of currentNode.referencedNode.edges) {\n        let neighbour = new PathNode(edge.targetNode, currentNode, edge.cost);\n        // do we nkow about this neighbour already\n        const searchForPathNode = (pathNode) => neighbour.x === pathNode.x && neighbour.y === pathNode.y;\n        \n        // look for a knownPathNode that is on the open or closed list\n        let knownPathNode = openList.find(searchForPathNode) || closedList.find(searchForPathNode);\n\n        // if we know this node\n        if (knownPathNode) {\n          // check it for a better solution\n          if (knownPathNode.g < neighbour.g) {\n            knownPathNode.parent = neighbour.parent;\n            knownPathNode.degreesOfSeperation = neighbour.degreesOfSeperation;\n            knownPathNode.g = neighbour.g;\n          }\n        } else {\n          openList.push(neighbour);\n        };\n      };\n\n      openList = openList.sort((a, b) => {\n        return a.g - b.g;\n      });\n    }\n  };\n\n\n\n  this.aStar = () => {\n    let closedList = this.createPriorityQueue();\n    // find absolute distance to target after travelling down an edge\n    const h = candidateNode => {\n      let manhattanDistance =\n        Math.abs(end.xPos - candidateNode.xPos) +\n        Math.abs(end.yPos - candidateNode.yPos);\n      return manhattanDistance;\n    };\n\n    // current cost so far\n    const g = pathNodeIndex => {\n      let gScore = 0;\n      let finishedBacktrack = false;\n\n      while (!finishedBacktrack) {\n        //TODO traverse backwards through the closedList parent thingy\n        // closedList[pathNodeIndex];\n      }\n\n      return gScore;\n    };\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let openList = this.createpriorityQueue();\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n    while (currentNode !== end) {\n      // map to an array arranged by priority, then join it to the open list\n      //\n    }\n  };\n};\n\n/**\n * a node to go on the closed list stac\n * @param sourceNode {GraphNode} the graph node this represents\n * @param parent {PathNode} - the parent PathNode\n */\nfunction PathNode(sourceNode, parent = null, cost = 0) {\n  this.referencedNode = sourceNode;\n  this.x = sourceNode.xPos;\n  this.y = sourceNode.yPos;\n  this.parent = parent;\n\n  this.degreesOfSeperation = parent === null ? 0 : parent.degreesOfSeperation + 1;\n  this.g = parent === null ? 0 : parent.g + cost;\n};\n\nexport default PathFinder;\n","import React, { useState } from \"react\";\nimport Circle from \"./Circle\";\nimport Edge from \"./Edge\";\nimport Interface from \"./Interface\";\nimport PathFinder from \"../algorithms/Pathfinder\";\n\nconst Graph = require(\"../map/Graph\");\nconst GraphData = new Graph();\nconst Pathfinder = new PathFinder(GraphData);\n\n// TODO Implement acess to the closed list so that we can show status of solver\n\nexport default function Map() {\n  const [totalNodes, setTotalNodes] = useState(100);\n  const [closedList, setClosedList] = useState(Pathfinder.closedList);\n  const [algorithm, setAlgorithm] = useState(\"bfs\");\n  const [startNode, setStartNode] = useState();\n  const [endNode, setEndNode] = useState();\n  const [solutionList, setSolutionList] = useState([]);\n  let solved = false;\n\n  // update the state of the map with the data from the algorithm\n  const tick = () => {\n    // update the Component's closedList in state\n    setClosedList(Pathfinder.closedList);\n    //\n    paint();\n\n    // Call the tick function again\n    if (!solved) {\n      tick();\n    }\n  };\n\n  const paint = () => {};\n\n  const startSolver = () => {\n    Pathfinder.startNode = startNode;\n    Pathfinder.endNode = endNode;\n    Pathfinder.config.algorithm = algorithm;\n    console.log(Pathfinder.config);\n    Pathfinder.solve();\n    solved = true;\n    setSolutionList(Pathfinder.solution);\n  };\n\n\n  const handleAlgorithmChange = (newAlgorithm) => {\n    setAlgorithm(newAlgorithm);\n  };\n  \n  // clear the map, reset the pathfinding algo\n  const resetSolver = () => {\n    console.log(\"reset solver triggered!\");\n  };\n\n  const setEndpoint = d => {\n    setStartNode(d);\n  };\n\n  const selectRandomNode = () => {\n    return GraphData.nodes[\n      // pick a random node out of the hat\n      Math.floor(Math.random() * Math.floor(GraphData.nodes.length))\n    ];\n  };\n\n  const paintStartNode = () => {\n    // default behaviour: pick a random node\n    if (!startNode) {\n      // make the initial startNode\n      let initialStartNode = selectRandomNode();\n      setStartNode(initialStartNode);\n    }\n  };\n\n  // sets the specified not or a random node as the end node\n  const paintEndNode = node => {\n    // if a node was passed into this function\n    if (node) {\n      setEndNode(node);\n    } else if (\n      // othewise, if theres no end node already defined\n      !endNode ||\n      // or if the end node is actually the start node\n      (endNode.xPos === startNode.xPos && endNode.yPos === startNode.yPos)\n    ) {\n      // set a random node as the start node\n      let randomEndNode = selectRandomNode();\n      setEndNode(randomEndNode);\n    }\n    // run it recursively to check if we set the wrong node\n    paintStartNode();\n  };\n\n  paintStartNode();\n  paintEndNode();\n\n  const chooseNodeColor = node => {\n    // if (!closedList) {\n    //   // normal node color\n    //   return \"rgba(88, 110, 117, 1)\";\n\n    //   // if the node data is in the closed list, change its color!\n    // } else if (\n    //   closedList.some(\n    //     pathNode =>\n    //       pathNode.x === node.data.xPos && pathNode.y === node.data.yPos\n    //   )\n    // ) {\n    //   // solarizedmagenta\n    //   return \"rgba(211, 54, 130, 1)\";\n    // }\n  };\n\n  const printNodeId = ({ xPos, yPos }) => {\n    let returnValue = undefined;\n    \n    if (startNode && endNode && closedList) {\n      // if it's the start node\n      if (xPos === startNode.xPos && yPos === startNode.yPos) {\n        return \"startNode\";\n        // or if it's the end node\n      } else if (xPos === endNode.xPos && yPos === endNode.yPos) {\n        return \"endNode\";\n      } else {\n        // or if it's on the closedList\n        let nodeIsVisited = closedList.some(item => {\n          return item.xPos === xPos && item.yPos === yPos;\n        });\n\n        if (nodeIsVisited) {\n          return \"visited\";\n        }\n      }\n    }\n  };\n\n  let nodes = GraphData.nodes.map((node, key) => {\n    return (\n      <Circle\n        data={node}\n        key={key}\n        r=\"6\"\n        color={chooseNodeColor(node)}\n        setEndpoint={x => setEndpoint(x)}\n        id={printNodeId(node)}\n      />\n    );\n  });\n\n  return (\n    <>\n      <Interface\n        totalNodes={totalNodes}\n        setTotalNodes={x => setTotalNodes(x)}\n        setAlgorithm={x => handleAlgorithmChange(x)}\n        startSolver={() => startSolver()}\n        resetSolver={() => resetSolver()}\n      />\n      <svg width={window.innerWidth} height={window.innerHeight}>\n        {edges}\n        {nodes}\n      </svg>\n    </>\n  );\n};\n\nGraphData.generateSeedMap();\n\n// make a list of the nodes for\n\nlet edges = [];\n\n// put edges on the map\nGraphData.nodes.forEach(node => {\n  let x1 = node.xPos;\n  let y1 = node.yPos;\n  edges.push(\n    node.edges.map((edge, key) => {\n      return (\n        <Edge x1={x1} y1={y1} data={edge} key={key} className={undefined} />\n      );\n    })\n  );\n});\n","import React from 'react';\nimport './App.css';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <main>\n      <Map />\n    </main>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}