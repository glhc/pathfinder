{"version":3,"sources":["map/Graph.js","map/GraphNode.js","map/GraphEdge.js","components/Circle.js","components/Edge.js","components/Interface.js","algorithms/Pathfinder.js","components/Map.js","App.js","serviceWorker.js","index.js"],"names":["GraphNode","require","Edge","module","exports","this","calculateCost","sourceNode","targetNode","xDist","xPos","yDist","yPos","Math","sqrt","addEdge","cost","undefined","edges","push","createNode","node","nodes","connectNearbyNodes","costThreshold","length","forEach","consideredNode","findNode","x","y","find","populateGraph","isGrid","generateSeedMap","config","xInterval","floor","window","innerWidth","yInterval","innerHeight","offset","intervalLength","random","i","j","iDistributed","jDistributed","Circle","data","r","color","setEndpoint","solutionNodes","id","classes","isSolved","classNames","circle","solution","some","partOfTheSolution","cx","cy","fill","onClick","e","console","log","className","x1","y1","x2","y2","useEffect","isSolutionPath","Interface","totalNodes","setTotalNodes","setAlgorithm","startSolver","resetSolver","htmlFor","type","name","min","max","onChange","Number","target","value","preventDefault","PathNode","parent","referencedNode","degreesOfSeperation","g","PathFinder","graph","algorithm","reset","closedList","openList","endNode","startNode","obtainSolution","finalPFNode","currentNode","currentSolution","PriorityQueue","priorityQueue","enqueue","priority","findIndex","element","bind","dequeue","shift","setStartNode","origin","Error","setEndNode","solve","bfs","dfs","djikstra","aStar","start","end","edge","neighbour","searchForPathNode","pathNode","knownPathNode","findAdjacent","map","sort","a","b","createPriorityQueue","createpriorityQueue","GraphData","Pathfinder","Map","useState","solutionList","setSolutionList","solved","setSolved","handleAlgorithmChange","newAlgorithm","selectRandomNode","paintStartNode","initialStartNode","paintEndNode","randomEndNode","printNodeId","item","key","chooseNodeColor","width","height","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9610077c.chunk.js","sourcesContent":["const GraphNode = require(\"./GraphNode\");\nconst Edge = require(\"./GraphEdge\");\n\n/**\n * Generates a graph map\n * @constructor\n * @classdesc A Graph of interconnected nodes\n */\nfunction Graph() {\n  /**\n   * Calculates the cost along the edge of a node\n   * @method\n   */\n  this.calculateCost = function(sourceNode, targetNode) {\n    let xDist = targetNode.xPos - sourceNode.xPos;\n    let yDist = targetNode.yPos - sourceNode.yPos;\n\n    return Math.sqrt(xDist * xDist + yDist * yDist);\n  };\n\n  /**\n   * Adds an edge between two nodes.\n   * @method\n   */\n  this.addEdge = function(sourceNode, targetNode, cost) {\n    // Figure out the cost if it wasn't passed into this function\n    if (cost === undefined) {\n      cost = this.calculateCost(sourceNode, targetNode);\n    }\n\n    //add the edge to the source node\n    sourceNode.edges.push(new Edge(targetNode, cost));\n  };\n\n  /**\n   * Adds a node to the graph\n   * @method\n   * @param {Number} xPos - The x-position of the node\n   * @param {Number} yPos - The y-position of the node.\n   * @returns {Node} - The node that was just added\n   * @todo Check for pre-existing node before adding another identical one\n   */\n  this.createNode = function(xPos, yPos) {\n    let node = new GraphNode(xPos, yPos);\n    this.nodes.push(node);\n    return node;\n  };\n\n  /**\n   * connects the nearby nodes together\n   * @method\n   * @param {Number} costThreshold - The maximum for which\n   * nodes will be connected\n   */\n  this.connectNearbyNodes = function(costThreshold) {\n    if (this.nodes.length > 0) {\n      for (let node of this.nodes) {\n        // create a list of nodes that are within or equal to the cost threshold\n        this.nodes.forEach(consideredNode => {\n          if (consideredNode !== node) {\n            let cost = this.calculateCost(node, consideredNode);\n            if (cost <= costThreshold) {\n              this.addEdge(node, consideredNode, cost);\n            }\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * finds a node based on the co-ords provided\n   * @param {Number} x - The x-position of the node\n   * @param {Number} y - The y-position of the node\n   * @returns {(Node|undefind)} - Node if exists\n   */\n  this.findNode = function(x, y, radius = 1) {\n    // find closest node based on area search of area defined by radius\n    // return this.nodes.filter(node => {\n    //   let xDist = x - node.xPos;\n    //   let yDist = y - node.yPos;\n    //   return Math.sqrt(xDist * xDist + yDist * yDist) <= radius;\n    // });\n\n    // if the coords are right, return the node\n    return this.nodes.find(node => {\n      return node.x === x && node.y === y;\n    });\n  };\n\n  /**\n   * @member {Array.<GraphNodes>} nodes - A list of nodes\n   */\n  this.nodes = [];\n\n  this.populateGraph = function(isGrid) {\n    if (isGrid) {\n\n    };\n  };\n\n  this.generateSeedMap = () => {\n    const config = {\n      // iMax: Math.floor(0.02 * window.innerWidth),\n      iMax: 16,\n      jMax: 9 \n    };\n\n    let xInterval = Math.floor(window.innerWidth / config.iMax);\n    let yInterval = Math.floor(window.innerHeight / config.jMax);\n\n    const offset = (intervalLength) => Math.random() * intervalLength;\n\n    for (let i = 1; i < config.iMax; i++) {\n      for (let j = 1; j < config.jMax; j++) {\n        let iDistributed = Math.floor((i * xInterval) + offset(xInterval) - offset(xInterval));\n        let jDistributed = Math.floor((j * xInterval) + offset(yInterval) - offset(yInterval));\n        // info.push({x: iDistributed, y: jDistributed});\n        this.createNode(iDistributed, jDistributed);\n      }\n    }\n    this.connectNearbyNodes(210);\n  };\n};\n\nmodule.exports = Graph;\n","/**\n * A Node in the graph\n * @constructor\n * @param {Number} xPos - The x-position of the Graph Node\n * @param {Number} yPos - The y-position of the Graph Node\n *\n * @property {Number} xPos - The x-position of the node\n * @property {Number} yPos - The y-position of the node\n * @property {Array.<Edge>} edges - A list of all the edges connected to this node\n */\nmodule.exports = function GraphNode(xPos, yPos) {\n  this.xPos = xPos;\n  this.yPos = yPos;\n  this.edges = [];\n}\n\n","/**\n * An edge connecting two GraphNodes together\n * @constructor\n * @param {Node} sourceNode - the source node\n * @param {Node} targetNode - the target node\n * @prop {Node} sourceNode - the source node\n * @prop {Node} targetNode - the target node\n */\nmodule.exports = function GraphEdge(targetNode, cost) {\n  this.targetNode = targetNode;\n  this.cost = cost;\n};\n","import React from \"react\";\nimport classNames from 'classnames';\n\nexport default function Circle({\n  data,\n  r,\n  color,\n  setEndpoint,\n  solutionNodes,\n  id,\n  isSolved\n}) {\n\n  const handleClick = e => {\n    console.log(e);\n    setEndpoint(data);\n  };\n\n  const partOfTheSolution = () => {\n    if (solutionNodes) {\n      return solutionNodes.some(\n        node => node.xPos === data.xPos && node.yPos === data.yPos\n      );\n    }\n  };\n\n  let classes = classNames({\n    circle: true,\n    solution: partOfTheSolution()\n  });\n\n  return (\n    <circle\n      cx={data.xPos}\n      cy={data.yPos}\n      r={r}\n      fill={color}\n      onClick={handleClick}\n      id={id ? id : undefined}\n      className={classes}\n    ></circle>\n  );\n}\n","import React, {useEffect} from \"react\";\nimport classNames from 'classnames';\n\nexport default function Edge({ x1, y1, data, solutionNodes}) {\n  // const displayStats = true;\n  const x2 = data.targetNode.xPos;\n  const y2 = data.targetNode.yPos;\n\n\n  \n  //x1 needs to match something from soln list\n  //x2 needs to match something from soln list\n  //y1 needs to match something from soln list\n  //y2 needs to match something from soln list\n\n  useEffect(() => {\n    if(solutionNodes) {\n      debugger;\n    }\n  });\n\n  const partOfTheSolution = () => {\n  let isSolutionPath = false;\n    if (solutionNodes) {\n      isSolutionPath =\n        (\n          solutionNodes.some(node => node.xPos === x1) &&\n          solutionNodes.some(node => node.yPos === y1)\n        ) ||\n        (\n          solutionNodes.some(node => node.xPos === x2) &&\n          solutionNodes.some(node => node.yPos === y2 || y2)\n        );\n    }\n    return isSolutionPath;\n  };\n\n\n  // const info = (\n  //   <text\n  //     x={(x1 + (x1 + x2) / 2) + 'px'}\n  //     y={(y1 + (y1 + y2) / 2) + 'px'}\n  //     dx=\"5px\"\n  //   >\n  //   </text>\n  // );\n\n  let classes = classNames({\n    solution: partOfTheSolution(),\n  });\n\n  return (\n    <>\n      <line x1={x1} y1={y1} x2={x2} y2={y2} className={classes}>\n      </line>\n    </>\n  );\n}\n","import React from \"react\";\n\nexport default function Interface({\n  totalNodes,\n  setTotalNodes,\n  setAlgorithm,\n  startSolver,\n  resetSolver\n}) {\n\n\n  const handleNodeChange = e => {\n    setTotalNodes(Number(e.target.value));\n  };\n\n  const handleAlgorithmChange = e => {\n    setAlgorithm(e.target.id);\n  };\n\n  const handleStartCommand = e => {\n    e.preventDefault();\n    startSolver();\n  };\n\n  const handleResetCommand = e => {\n    e.preventDefault();\n    resetSolver();\n  };\n\n  return (\n    <aside>\n      <h1>Pathfinder</h1>\n      <label htmlFor=\"totalNodes\">\n        # of Nodes: {totalNodes}\n          <input\n            type=\"range\"\n            id=\"totalNodes\"\n            name=\"totalNodes\"\n            min=\"2\"\n            max=\"100\"\n            onChange={handleNodeChange}\n          ></input>\n        </label>\n\n      <br />\n\n      <form onChange={handleAlgorithmChange}>\n        <label htmlFor=\"bfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"bfs\"></input>\n          Breadth-First Search\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"dfs\"></input>\n          Depth-First Search\n        </label>\n\n        <label htmlFor=\"djikstra\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"djikstra\"></input>\n          Djikstra's Algorithm\n        </label>\n\n        <label htmlFor=\"dfs\" className=\"list-item\">\n          <input type=\"radio\" name=\"algorithm\" id=\"aStar\"></input>\n          A* Search\n        </label>\n      </form>\n\n      <div className=\"buttons\">\n        <label htmlFor=\"start\">\n          <button id=\"start\" name=\"start\" onClick={handleStartCommand}>\n          Start\n          </button>\n        </label>\n\n        <label htmlFor=\"reset\">\n          <button id=\"reset\" name=\"reset\" onClick={handleResetCommand}>\n          Reset\n          </button>\n        </label>\n    </div>\n    </aside>\n  );\n}\n","/**\n * This is the prototype for all algorithms.\n * @param {Object} graph - The graph upon which the Pathfinder is to solve\n *\n * @todo - Stack generator function\n * @todo - Queue generator function\n * @todo - Priority queue generator function\n */\nfunction PathFinder(graph, algorithm = \"bfs\") {\n  this.config = {\n    algorithm: algorithm,\n  };\n\n  this.solution = null;\n\n  this.reset = () => {\n    this.solution = [];\n    this.closedList = [];\n    this.openList = [];\n    this.endNode = null;\n    this.startNode = null;\n  };\n\n  this.obtainSolution = (finalPFNode) => {\n    let currentNode = finalPFNode;\n    let currentSolution = [];\n\n    while (currentNode !== null) {\n      currentSolution.push(currentNode.referencedNode);\n      currentNode = currentNode.parent;\n    };\n\n    console.log(currentSolution);\n    return currentSolution;\n  };\n\n  this.PriorityQueue = () => {\n    let priorityQueue = {};\n    // add with key based on.... hScore?\n    // priorityQueue.createPriorityItem\n    // Object.defineProperty(priorityQueue, )\n\n    /**\n     * creates an item to add to a priority queue\n     * @typedef\n     * @constructor\n     * @param {Number} x - x-position\n     * @param {Number} y - y-position\n     * @param {Number} priority - the priority, with higher value = higher priority\n     * @returns {Object} - item with priority\n     */\n    function createPriorityItem(node, priority) {\n      this.node = node;\n      this.priority = priority;\n    }\n\n    /** adds an item in a sorted way. assumes highest priority if priority\n     *  if the priority is not specified\n     *  @param {number} x - the x position of the item\n     *  @param {number} y - the y position of the item\n     *  @param {number} priority - the priority of the item (max priority = 0)\n     */\n    const enqueue = (x, y, priority = 0) => {\n      let priorityIndex = 0;\n\n      if (priority) {\n        priorityIndex = priorityQueue.findIndex(\n          element => element.priority === priority\n        );\n      } else {\n        priority = 0;\n      }\n\n      // place the item in an array sorted by priority\n      // priorityQueue.splice(priorityIndex, prioritisedItem(x, y, priority));\n    };\n\n    priorityQueue.enqueue = enqueue.bind(priorityQueue);\n\n    /**\n     * gives the highest priority item by default.\n     * If the priority is specified, returns an item of that priority\n     * which has been randomly selected.\n     * @returns {Object}\n     */\n    function dequeue() {\n      return this.shift();\n    }\n\n    priorityQueue.dequeue = dequeue.bind(priorityQueue);\n\n    return priorityQueue;\n  };\n\n  this.startNode = null;\n\n  this.setStartNode = (x, y) => {\n    let origin = graph.findNode(x, y);\n\n    if (origin !== undefined) {\n      // console.debug(graph.findNode(x, y))\n      this.startNode = origin;\n    } else {\n      throw new Error(\n        `Couldn't find the start node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n  this.endNode = () => null;\n\n  this.setEndNode = (x, y) => {\n    let endNode = graph.findNode(x, y);\n    if (endNode) {\n      endNode = endNode;\n    } else {\n      throw new Error(\n        `Couldn't find the end node you specified at x: ${x}, ` +\n          `y: ${y}, graph: ${graph}`\n      );\n    }\n  };\n\n  this.solve = () => {\n    if (this.config.algorithm === \"bfs\") {\n      this.bfs();\n    } else if (this.config.algorithm === \"dfs\") {\n      this.dfs();\n    } else if (this.config.algorithm === \"djikstra\") {\n      this.djikstra();\n    } else if (this.config.algorithm === \"aStar\") {\n      this.aStar();\n    }\n  };\n\n  this.closedList = [];\n  this.openList = [];\n\n  this.bfs = () => {\n    const openList = this.openList;\n    const closedList = this.closedList;\n\n    const start = this.startNode;\n    const end = this.endNode;\n\n    // add the first node (start node) to the closed list with null parent\n    openList.push(new PathNode(start));\n\n    while (openList.length > 0) {\n      // choose best node on the open list\n      const currentNode = openList.shift();\n      closedList.push(currentNode);\n\n      if (currentNode.referencedNode === end) {\n        this.solution = this.obtainSolution(currentNode);\n        break;\n      };\n\n      for (let edge of currentNode.referencedNode.edges) {\n        let neighbour = new PathNode(edge.targetNode, currentNode, edge.cost);\n        // do we nkow about this neighbour already\n        const searchForPathNode = (pathNode) => neighbour.x === pathNode.x && neighbour.y === pathNode.y;\n        \n        // look for a knownPathNode that is on the open or closed list\n        let knownPathNode = openList.find(searchForPathNode) || closedList.find(searchForPathNode);\n\n        // if we know this node\n        if (knownPathNode) {\n          // check it for a better solution\n          if (knownPathNode.degreesOfSeperation > neighbour.degreesOfSeperation) {\n            knownPathNode.parent = neighbour.parent;\n            knownPathNode.degreesOfSeperation = neighbour.degreesOfSeperation;\n            knownPathNode.g = neighbour.g;\n          }\n        } else {\n          openList.push(neighbour);\n        };\n      };\n    }\n  };\n\n  this.findAdjacent = node => {\n    return node.edges.map(edge => edge.targetNode);\n  };\n\n  // not going to work\n  this.dfs = () => {\n  };\n\n\n  // TODO implement setting of this.closedList to empty to empty priority queue\n  // TODO define cost to pass into pathnodes\n  // TODO when a known node is updated, the gscore, hscore, fscore would update and so would the priority\n  this.djikstra = () => {\n    console.log('djistra triggered');\n    let openList = this.openList;\n    let closedList = this.closedList;\n\n    let start = this.startNode;\n    let end = this.endNode;\n\n    // add the first node (start node) to the closed list with null parent\n    openList.push(new PathNode(start));\n\n    while (openList.length > 0) {\n      // choose best node on the open list\n      const currentNode = openList.shift();\n      closedList.push(currentNode);\n\n      if (currentNode.referencedNode === end) {\n        this.solution = this.obtainSolution(currentNode);\n        break;\n      };\n\n      for (let edge of currentNode.referencedNode.edges) {\n        let neighbour = new PathNode(edge.targetNode, currentNode, edge.cost);\n        // do we nkow about this neighbour already\n        const searchForPathNode = (pathNode) => neighbour.x === pathNode.x && neighbour.y === pathNode.y;\n        \n        // look for a knownPathNode that is on the open or closed list\n        let knownPathNode = openList.find(searchForPathNode) || closedList.find(searchForPathNode);\n\n        // if we know this node\n        if (knownPathNode) {\n          // check it for a better solution\n          if (knownPathNode.g < neighbour.g) {\n            knownPathNode.parent = neighbour.parent;\n            knownPathNode.degreesOfSeperation = neighbour.degreesOfSeperation;\n            knownPathNode.g = neighbour.g;\n          }\n        } else {\n          openList.push(neighbour);\n        };\n      };\n\n      openList = openList.sort((a, b) => {\n        return a.g - b.g;\n      });\n    };\n\n  };\n\n\n\n  this.aStar = () => {\n    let closedList = this.createPriorityQueue();\n    // find absolute distance to target after travelling down an edge\n    const h = candidateNode => {\n      let manhattanDistance =\n        Math.abs(end.xPos - candidateNode.xPos) +\n        Math.abs(end.yPos - candidateNode.yPos);\n      return manhattanDistance;\n    };\n\n    // current cost so far\n    const g = pathNodeIndex => {\n      let gScore = 0;\n      let finishedBacktrack = false;\n\n      while (!finishedBacktrack) {\n        //TODO traverse backwards through the closedList parent thingy\n        // closedList[pathNodeIndex];\n      }\n\n      return gScore;\n    };\n\n    const start = this.startNode;\n    const end = this.endNode;\n    let openList = this.createpriorityQueue();\n    let currentNode = start;\n    closedList.push(new PathNode(start));\n    while (currentNode !== end) {\n      // map to an array arranged by priority, then join it to the open list\n      //\n    }\n  };\n};\n\n/**\n * a node to go on the closed list stac\n * @param sourceNode {GraphNode} the graph node this represents\n * @param parent {PathNode} - the parent PathNode\n */\nfunction PathNode(sourceNode, parent = null, cost = 0) {\n  this.referencedNode = sourceNode;\n  this.x = sourceNode.xPos;\n  this.y = sourceNode.yPos;\n  this.parent = parent;\n\n  this.degreesOfSeperation = parent === null ? 0 : parent.degreesOfSeperation + 1;\n  this.g = parent === null ? 0 : parent.g + cost;\n};\n\nexport default PathFinder;\n","import React, { useState } from \"react\";\nimport classNames from \"classnames\";\nimport Circle from \"./Circle\";\nimport Edge from \"./Edge\";\nimport Interface from \"./Interface\";\nimport SolnCircle from \"./SolnCircle\";\nimport PathFinder from \"../algorithms/Pathfinder\";\n\nconst Graph = require(\"../map/Graph\");\nconst GraphData = new Graph();\nconst Pathfinder = new PathFinder(GraphData);\n\n// TODO Implement acess to the closed list so that we can show status of solver\n\nexport default function Map() {\n  const [totalNodes, setTotalNodes] = useState(100);\n  const [closedList, setClosedList] = useState(Pathfinder.closedList);\n  const [algorithm, setAlgorithm] = useState(\"bfs\");\n  const [startNode, setStartNode] = useState();\n  const [endNode, setEndNode] = useState();\n  const [solutionList, setSolutionList] = useState([]);\n  const [solved, setSolved] = useState(false);\n\n  // update the state of the map with the data from the algorithm\n  const tick = () => {\n    // update the Component's closedList in state\n    setClosedList(Pathfinder.closedList);\n    //\n    paint();\n\n    // Call the tick function again\n    if (!solved) {\n      tick();\n    }\n  };\n\n  const paint = () => {};\n\n  let solutionNodes = [];\n\n  const startSolver = () => {\n    Pathfinder.startNode = startNode;\n    Pathfinder.endNode = endNode;\n    Pathfinder.config.algorithm = algorithm;\n    Pathfinder.solve();\n    setSolutionList(Pathfinder.solution);\n    // setSolved(true);\n    // solutionNodes = Pathfinder.solution.map((node, key) => {\n    //   return (\n    //     ''\n    //   );\n    // });\n  };\n\n  const handleAlgorithmChange = newAlgorithm => {\n    setAlgorithm(newAlgorithm);\n  };\n\n  // clear the map, reset the pathfinding algo\n  const resetSolver = () => {\n    Pathfinder.reset();\n    setSolutionList([]);\n    setSolved(false);\n    GraphData.nodes = [];\n    edges = [];\n    GraphData.generateSeedMap();\n    GraphData.nodes.forEach(node => {\n      let x1 = node.xPos;\n      let y1 = node.yPos;\n      edges.push(\n        node.edges.map((edge, key) => {\n          return (\n            <Edge\n              x1={x1}\n              y1={y1}\n              data={edge}\n              key={key}\n              className={undefined}\n              solutionNodes={Pathfinder.solution}\n            />\n          );\n        })\n      );\n    });\n    setStartNode(undefined);\n    setEndNode(undefined);\n    paintStartNode();\n    paintEndNode();\n  };\n\n  const setEndpoint = d => {\n    setStartNode(d);\n  };\n\n  const selectRandomNode = () => {\n    return GraphData.nodes[\n      // pick a random node out of the hat\n      Math.floor(Math.random() * Math.floor(GraphData.nodes.length))\n    ];\n  };\n\n  const paintStartNode = () => {\n    // default behaviour: pick a random node\n    if (!startNode) {\n      // make the initial startNode\n      let initialStartNode = selectRandomNode();\n      setStartNode(initialStartNode);\n    }\n  };\n\n  // sets the specified not or a random node as the end node\n  const paintEndNode = node => {\n    // if a node was passed into this function\n    if (node) {\n      setEndNode(node);\n    } else if (\n      // othewise, if theres no end node already defined\n      !endNode ||\n      // or if the end node is actually the start node\n      (endNode.xPos === startNode.xPos && endNode.yPos === startNode.yPos)\n    ) {\n      // set a random node as the start node\n      let randomEndNode = selectRandomNode();\n      setEndNode(randomEndNode);\n    }\n    // run it recursively to check if we set the wrong node\n    paintStartNode();\n  };\n\n  paintStartNode();\n  paintEndNode();\n\n  const chooseNodeColor = node => {\n    // if (!closedList) {\n    //   // normal node color\n    //   return \"rgba(88, 110, 117, 1)\";\n    //   // if the node data is in the closed list, change its color!\n    // } else if (\n    //   closedList.some(\n    //     pathNode =>\n    //       pathNode.x === node.data.xPos && pathNode.y === node.data.yPos\n    //   )\n    // ) {\n    //   // solarizedmagenta\n    //   return \"rgba(211, 54, 130, 1)\";\n    // }\n  };\n\n  const printNodeId = ({ xPos, yPos }) => {\n    let returnValue = undefined;\n\n    if (startNode && endNode && closedList) {\n      // if it's the start node\n      if (xPos === startNode.xPos && yPos === startNode.yPos) {\n        return \"startNode\";\n        // or if it's the end node\n      } else if (xPos === endNode.xPos && yPos === endNode.yPos) {\n        return \"endNode\";\n      } else {\n        // or if it's on the closedList\n        let nodeIsVisited = closedList.some(item => {\n          return item.xPos === xPos && item.yPos === yPos;\n        });\n        if (nodeIsVisited) {\n          return \"visited\";\n        }\n      }\n    }\n  };\n\n  let nodes = GraphData.nodes.map((node, key) => {\n    return (\n      <Circle\n        data={node}\n        key={key}\n        r=\"6\"\n        color={chooseNodeColor(node)}\n        setEndpoint={x => setEndpoint(x)}\n        id={printNodeId(node)}\n        solutionNodes={solutionList}\n        isSolved={solved}\n      />\n    );\n  });\n\n  return (\n    <>\n      <Interface\n        totalNodes={totalNodes}\n        setTotalNodes={x => setTotalNodes(x)}\n        setAlgorithm={x => handleAlgorithmChange(x)}\n        startSolver={() => startSolver()}\n        resetSolver={() => resetSolver()}\n      />\n      <svg width={window.innerWidth} height={window.innerHeight}>\n        {edges}\n        {nodes}\n      </svg>\n    </>\n  );\n}\n\nGraphData.generateSeedMap();\n\n// make a list of the nodes for\n\nlet edges = [];\n\n// put edges on the map\nGraphData.nodes.forEach(node => {\n  let x1 = node.xPos;\n  let y1 = node.yPos;\n  edges.push(\n    node.edges.map((edge, key) => {\n      return (\n        <Edge\n          x1={x1}\n          y1={y1}\n          data={edge}\n          key={key}\n          className={undefined}\n          solutionNodes={Pathfinder.solution}\n        />\n      );\n    })\n  );\n});\n","import React from 'react';\nimport './App.css';\nimport Map from './components/Map';\n\nfunction App() {\n  return (\n    <main>\n      <Map />\n    </main>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}